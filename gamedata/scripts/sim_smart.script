smart_spawn_limit = {
  base = 5,
  camp = 4,
  resource = 3,
  territory = 2,
  point = 2,
  lair = 1
}
spawned_leaders_squads = {}
already_captured_smarts = {}
prioritySmartsTable = {}
pda_smart_icons_size_old = nil
pda_smart_icons_size_new = nil
pda_smart_icons_color_old = nil
pda_smart_icons_color_new = nil

hunt_by_actor_time = {}
hunt_by_actor_infinity = {}

mutants_by_level = {}
local traderOnSmartTable = {}
local gs = GetString

--��������
--������
--������
--�����
--���������� ��������
--���������

uniqueSmarts = {
  -- Marsh
  ["mar_dvor"] = {1, 1, 1, 1, 0},
  ["mar_smart_terrain_base"] = {1, 1, 1, 1, 0},
  -- Escape
  ["esc_smart_terrain_farm"] = {1, 1, 1, 1, 0},
  ["esc_smart_terrain_derevnya"] = {1, 1, 1, 1, 0},
  ["esc_military_blokpost"] = {1, 1, 0, 1, 0},
  -- Garbage
  ["gar_smart_terrain_baraholka"] = {0, 0, 0, 0, 1},
  ["gar_smart_terrain_depo"] = {1, 1, 1, 1, 0},
  -- Dark Valley
  ["val_smart_terrain_7_3"] = {0, 1, 0, 0, 0},
  ["val_smart_terrain_7_4"] = {1, 0, 0, 0, 0},
  ["val_smart_terrain_1_2"] = {1, 1, 1, 1, 0},
  -- Agroprom
  ["agr_fabric"] = {1, 1, 0, 1, 0},
  ["agr_army_hq"] = {1, 1, 1, 1, 0},
  -- Rostok
  ["bar_hq_duty"] = {1, 1, 1, 1, 0},
  ["bar_bar"] = {1, 1, 0, 0, 0},
  ["bar_middle_house"] = {1, 1, 0, 0, 0},
  ["ros_vagon_camp"] = {1, 1, 1, 1, 0},
  -- Military
  ["mil_armybase"] = {1, 1, 0, 1, 0},
  ["mil_north_farmstead"] = {0, 0, 0, 0, 1},
  -- Deadcity
  ["cit_killers"] = {1, 1, 1, 1, 0},
  ["cit_bar"] = {1, 1, 1, 1, 0},
  -- Pripyat(West)
  ["pri_monolith"] = {1, 1, 1, 1, 0},
  ["pri_laundry_main"] = {1, 1, 1, 1, 0},
  ["pri_kino_build"] = {1, 1, 1, 1, 0},
  ["pri_shop_books"] = {1, 1, 0, 0, 0},
  -- Pripyat(East)
  ["pri_sim_1"] = {1, 1, 1, 1, 0},
  ["pri_a18_smart_terrain"] = {1, 1, 0, 0, 0},
  ["pri_a16"] = {1, 1, 0, 1, 0},
  -- Zaton
  ["zat_mercbase"] = {1, 1, 1, 1, 0},
  ["zat_skadovsk"] = {1, 1, 1, 1, 0},
  ["zat_stone_forest_base"] = {1, 1, 1, 1, 0},
  ["zat_foresty"] = {1, 1, 1, 1, 0},
  ["zat_vnz_u"] = {1, 1, 0, 0, 0},
  ["zat_vnz"] = {1, 1, 0, 0, 0},
  ["zat_camp_merc"] = {0, 0, 0, 0, 1},
  -- hospital
  ["hos_main"] = {1, 1, 1, 1, 0},
  -- Jupiter
  ["jup_factory"] = {1, 1, 1, 1, 0},
  ["jup_yanov"] = {1, 1, 1, 1, 0},
  ["jup_bunker"] = {1, 1, 0, 1, 0},
  ["jup_tunnel"] = {1, 1, 0, 0, 0},
  ["jup_north_build"] = {1, 1, 0, 0, 0},
  ["jup_kpp"] = {1, 1, 0, 0, 0},
  ["jup_subfactory"] = {1, 1, 0, 0, 0},
  ["jup_volkhov"] = {1, 1, 0, 0, 0},
  ["jup_south_warmware"] = {1, 1, 0, 0, 0},
  ["jup_broken_tunnel"] = {1, 1, 0, 0, 0},
  ["jup_factory_hellicopter"] = {0, 0, 0, 0, 1},
  -- Darkscape
  ["ds2_domik_st"] = {1, 1, 1, 1, 0},
  ["ds_smart_terrain_cave_base"] = {1, 1, 1, 1, 0},
  -- Radar
  ["rad_entrance"] = {0, 0, 0, 0, 1},
  ["rad2_prip_teleport"] = {1, 1, 0, 0, 0},
  ["rad_antenna_monolith"] = {1, 1, 1, 1, 0},
  -- Red forest
  ["red_bridge_right"] = {1, 1, 0, 0, 0},
  ["red_cave"] = {1, 1, 0, 0, 0},
  ["red_forester"] = {1, 1, 1, 1, 0},
  -- Limansk
  ["lim_north_base"] = {1, 1, 1, 1, 0},
  ["lim_twofloor_build"] = {0, 0, 0, 0, 1},
  -- Hospital
  ["katacomb_smart_terrain"] = {1, 1, 1, 1, 0},
  -- Stancia 1
  ["aes_monolit_in"] = {1, 1, 0, 0, 0},
  -- Yantar
  ["yan_ecolog_bunker"] = {1, 1, 1, 1, 0},
  ["yan_factory_yantar"] = {1, 1, 1, 1, 0},
  -- Atp
  ["atp_zavod"] = {1, 1, 0, 0, 0},
  -- Kurchatov
  ["kur_cultura"] = {1, 1, 1, 1, 0},
  -- Vokzal
  ["l2_9_masterskaya"] = {1, 1, 1, 1, 0},
  ["l2_9_tank"] = {1, 1, 0, 0, 0},
  -- Generators
  ["gen_base_pod"] = {1, 1, 0, 0, 0},
  ["gen_smart_terrain_lab_entrance_2"] = {1, 1, 0, 0, 0},
  -- Factory
  ["mlz_stroika"] = {1, 1, 0, 1, 0},
  ["mlz_anom"] = {0, 0, 1, 0, 0},
  -- Predbannik
  ["pre_bar"] = {1, 1, 1, 0, 0},
  ["pre_zavod"] = {0, 0, 0, 0, 1},
  ["pre_military_main"] = {1, 1, 1, 1, 0},
  ["pre_baza1"] = {1, 1, 1, 1, 0},
  ["pre_baza2"] = {0, 0, 0, 1, 0},
  ["pre_sim_3"] = {1, 1, 0, 0, 0},
  -- Puzir
  ["puz_base"] = {1, 1, 1, 1, 0},
  -- Polyana
  ["pol_smart_terrain_1_1"] = {0, 0, 0, 0, 1},
  ["pol_smart_terrain_2_1"] = {1, 1, 0, 0, 0},
  ["pol_zavod"] = {1, 1, 1, 1, 0},
  -- Hiding Road
  ["hgr_baza2"] = {1, 1, 1, 1, 0},
  -- Aver
  ["aver_hizhina"] = {0, 1, 0, 0, 0},
  ["aver_dungeon"] = {1, 0, 0, 0, 0},
  -- Warlab
  ["warlab_common_consciousness_smart_terrain"] = {1, 1, 1, 1, 0},
  -- Polyana
  ["pol_zavod"] = {1, 1, 1, 1, 0},
  --
  ["val_base_zavod"] = {1, 1, 1, 1, 0},
  ["val_zavod"] = {1, 1, 1, 1, 0},
  --
  ["trc_main_camp"] = {1, 1, 0, 0, 0},
  -- Rein
  ["rei_base"] = {1, 0, 1, 0, 0},
  ["rei_adm"] = {0, 1, 0, 1, 0},
  ["rei_ost_plosh"] = {1, 1, 0, 1, 0},
  ["rei_pol"] = {1, 1, 0, 1, 0},
  -- Science
  ["sci_iig"] = {1, 1, 1, 1, 0},
  ["sci_ecolog"] = {1, 1, 0, 0, 0},
  -- X16
  ["x162_st_poltergeist"] = {1, 1, 1, 1, 0},
  --
  ["ds_lesop"] = {1, 1, 0, 0, 0},
  ["ds_lesop_fortrees"] = {0, 0, 1, 1, 0}
}

defense_timers = {}
defense_next_update = {}

attack_timers = {}
attack_next_update = {}

mutant_timers = {}
mutant_next_update = {}

respawn_timers = {}
respawn_next_update = {}

unique_check_timers = {}
unique_check_next_update = {}

smart_owners = {}
-- ��� ������� ������. ��������� ��������: smarts, levels
selected_item = nil
items_type = nil
items = {}

items_page = 0
items_max = 0

----------------------------- �������
local saved_dialog
function add_dialog(p_id, id, phrase_id, cond, act)
  if not (saved_dialog) then
    return
  end

  local phrase = saved_dialog:AddPhrase(phrase_id, tostring(id), tostring(p_id), -10000)
  if not (phrase) then
    return
  end

  --printf("phrase_id = %s",phrase_id)

  local phrase_script = phrase:GetPhraseScript()
  if (cond) then
    if (type(cond) == "table") then
      for key, value in pairs(cond) do
        if (alun_utils.findfunction(value, _G)) then
          --table.insert(cond_list,value)
          phrase_script:AddPrecondition(value)
        else
          printf("dialog_manager:Error: No such function exists '%s'", value)
        end
      end
    else
      if (alun_utils.findfunction(cond, _G)) then
        --table.insert(cond_list,value)
        phrase_script:AddPrecondition(cond)
      else
        printf("dialog_manager:Error: No such function exists '%s'", cond)
      end
    end
  end

  if (act) then
    if (type(act) == "table") then
      for key, value in pairs(act) do
        if (alun_utils.findfunction(value, _G)) then
          phrase_script:AddAction(value)
        else
          printf("dialog_manager:Error: No such function exists '%s'", value)
        end
      end
    else
      if (alun_utils.findfunction(act, _G)) then
        phrase_script:AddAction(act)
      else
        printf("dialog_manager:Error: No such function exists '%s'", act)
      end
    end
  end
  return phrase_script
end

function add_script_dialog(p_id, id, phrase_id, cond, act)
  local d = add_dialog(p_id, id, phrase_id, cond, act)
  if (d) then
    d:SetScriptText(phrase_id)
  end
end

function set_actor_dialogs(npc, ini, name, dialog_section)
  if dialog_section == nil then
    return
  end
  local actor_dialogs_string = ini:r_string_ex(dialog_section, "id") or ""
  if actor_dialogs_string ~= nil then
    db.storage[npc:id()].actor_dialogs = parse_names(actor_dialogs_string)
  end

  local actor_disable = ini:r_string_ex(dialog_section, "disable") or ""
  if actor_disable ~= nil then
    db.storage[npc:id()].actor_disable = parse_names(actor_disable)
  end
end

-- ����/����� [��� ] [�����������] (���������) - ����� / �������
function alltext(actor, npc, sele)
  if items_type == "levels" then
    local level_id = items[items_page + sele]
    return gs(alife():level_name(level_id))
  end

  local smart_type_name = ""
  local action = ""

  local npc = dialogs.who_is_npc(actor, npc)
  local npc_squad = get_object_squad(npc)
  local npc_smart = xr_gulag.get_npc_smart(npc)
  local smart = items[items_page + sele]
  local script_to_text_smart = gs(smart:name())
  local faction = npc:character_community()
  local faction2 = smart.owning_faction
  local factionName = smart.owning_faction

  factionName = sim_tables.faction_names_buy_squad[faction2 or "none"]

  local relation = game_relations.get_factions_community(faction, faction2)
  if relation == nil then
    action = gs("st_sim_smart_action_capture")
  elseif relation >= 0 then
    action = gs("st_sim_smart_action_def")
  else
    action = gs("st_sim_smart_action_attack")
  end

  if (smart and smart.props) then
    if isBase(smart) then
      smart_type_name = gs("base")
    elseif isResource(smart) then
      smart_type_name = gs("resource")
    elseif isTerritory(smart) then
      smart_type_name = gs("territory")
    elseif isLair(smart) then
      smart_type_name = gs("lair")
    elseif isCamp(smart) then
      smart_type_name = gs("camp")
    elseif isPoint(smart) then
      smart_type_name = gs("point")
    end
  end

  return string.format("%s %s %s %s", smart_type_name, script_to_text_smart, factionName, action)
end

function txt1(a, b)
  return alltext(a, b, 1)
end
function txt2(a, b)
  return alltext(a, b, 2)
end
function txt3(a, b)
  return alltext(a, b, 3)
end
function txt4(a, b)
  return alltext(a, b, 4)
end
function txt5(a, b)
  return alltext(a, b, 5)
end

function send_squad_1(a, b)
  send_squad_on_target(a, b, 1)
end
function send_squad_2(a, b)
  send_squad_on_target(a, b, 2)
end
function send_squad_3(a, b)
  send_squad_on_target(a, b, 3)
end
function send_squad_4(a, b)
  send_squad_on_target(a, b, 4)
end
function send_squad_5(a, b)
  send_squad_on_target(a, b, 5)
end

function page_item(a, b, smart_index)
  if items_type == "smarts" then
    spawn_attack(a, b, items[items_page + smart_index])
  elseif items_type == "levels" then
    selected_item = items[items_page + smart_index]
    init_smarts_list(a, b)
  end
end
function page_item_1(a, b)
  page_item(a, b, 1)
end
function page_item_2(a, b)
  page_item(a, b, 2)
end
function page_item_3(a, b)
  page_item(a, b, 3)
end
function page_item_4(a, b)
  page_item(a, b, 4)
end
function page_item_5(a, b)
  page_item(a, b, 5)
end

function condition_item(actor, npc, selected_num)
  return items[items_page + selected_num] and true or false
end

function condition_item_1(a, b)
  return condition_item(a, b, 1)
end
function condition_item_2(a, b)
  return condition_item(a, b, 2)
end
function condition_item_3(a, b)
  return condition_item(a, b, 3)
end
function condition_item_4(a, b)
  return condition_item(a, b, 4)
end
function condition_item_5(a, b)
  return condition_item(a, b, 5)
end

function fill_list(a, npc)
  local npc = dialogs.who_is_npc(a, npc)
  if not npc then
    return false
  end

  local item_count = 0
  items = {}

  if items_type == "smarts" then
    local level_id = game_graph():vertex(alife():actor().m_game_vertex_id):level_id()
    if (level_id) then
      local level_info = sim_levels.level_information[selected_item or level_id]

      if (level_info) then
        for i, smartId in pairs(level_info.smarts) do
          local smart = alife_object(smartId)
          if smart then
            items[#items + 1] = smart
            item_count = item_count + 1
          end
        end
        if item_count > 0 then
          items_page = 0
          items_max = item_count

          return true
        end
      end
    end
  elseif items_type == "levels" then
    for level_id, level_info in pairs(sim_levels.level_information) do
      items[#items + 1] = level_id
      item_count = item_count + 1
    end
    if item_count > 0 then
      items_page = 0
      items_max = item_count

      return true
    end
  end

  selected_item = nil
end
function init_levels_list(a, npc)
  items_type = "levels"
  return fill_list(a, npc)
end
function init_smarts_list(a, npc)
  items_type = "smarts"
  return fill_list(a, npc)
end

function prev_item_page(a, npc)
  items_page = items_page - 5
  if (items_page < 0) then
    items_page = 0
  end
end

function next_item_page(a, b)
  items_page = items_page + 5
  if (items_page > items_max) then
    items_page = items_max - 5
  end
end

function spawn_defense(actor, npc)
  if (db.actor:money() < 30000) then
    utils.news_params(
      gs("st_sim_smart_money_title"),
      (gs("st_sim_smart_no_money_for_capture")),
      getSenderSmsIcon(sim_brain.actor_faction),
      0,
      15000
    )
    return
  end

  local npc = dialogs.who_is_npc(actor, npc)
  local smart = xr_gulag.get_npc_smart(npc)
  local faction = smart.owning_faction
  local script_to_text_smart = gs(smart:name())

  db.actor:give_money(-30000)
  sim_squad.create_squad(smart, faction, nil, nil, nil, 1)
  utils.news_params(
    gs("st_sim_smart_def_squad_title"),
    (gs("st_sim_smart_buy_def_squad") .. script_to_text_smart),
    getSenderSmsIcon(sim_brain.actor_faction),
    0,
    15000
  )
end

function send_squad_on_target(actor, npc, sele)
  local npc = dialogs.who_is_npc(actor, npc)
  local squad = get_object_squad(npc)
  local target = items[items_page + sele]
  local script_to_text_smart = gs(target:name())

  if (target) then
    alun_utils.execute_script_on_squad(npc, axr_companions.remove_from_actor_squad)

    sim_squad.set_target(squad, target.id)

    utils.news_params(
      gs("st_sim_smart_attack_squad_title"),
      (gs("st_sim_smart_sent_squad_to") .. script_to_text_smart .. "."),
      getSenderSmsIcon(sim_brain.actor_faction),
      0,
      15000
    )
  end
end

function spawn_attack(actor, npc, target)
  if (db.actor:money() < 30000) then
    utils.news_params(
      gs("st_sim_smart_money_title"),
      gs("st_sim_smart_no_money_for_capture"),
      getSenderSmsIcon(sim_brain.actor_faction),
      0,
      15000
    )
    return
  end

  local npc = dialogs.who_is_npc(actor, npc)
  local smart = xr_gulag.get_npc_smart(npc)
  if not smart then
    return
  end

  local sname = gs(smart:name())
  local script_to_text_smart = gs(target:name())
  local faction = smart.owning_faction

  if (target) then
    db.actor:give_money(-30000)
    sim_squad.create_squad(smart, faction, target, nil, nil, 1)

    utils.news_params(
      gs("st_sim_smart_attack_squad_title"),
      (gs("st_sim_smart_buy_attack_squad") ..
        sname .. gs("st_sim_smart_buy_attack_squad_2") .. script_to_text_smart .. gs("st_sim_smart_buy_attack_squad_3")),
      getSenderSmsIcon(sim_brain.actor_faction),
      0,
      15000
    )
  end

  return
end

function textinfo(a, b)
  return items_page .. "-" .. (items_page + 5) .. gs("st_sim_smart_total") .. items_max
end

function spawn_squad_condition(a, b)
  if not sim_brain.initialized then
    return false
  end

  local npc = dialogs.who_is_npc(a, b)
  if not npc then
    return false
  end

  local smart = xr_gulag.get_npc_smart(npc)

  if not smart then
    return false
  end

  local actor_faction = sim_brain.actor_faction
  local npc_faction = npc:character_community()

  if actor_faction ~= npc_faction then
    return false
  end

  return true
end

function spawn_squad_dialog_init(dialog)
  saved_dialog = dialog

  add_dialog("", 0, gs("st_sim_smart_dialog_1"))

  add_dialog(0, 1, gs("st_sim_smart_dialog_2"))

  add_dialog(1, 2, gs("st_sim_smart_dialog_3"), nil, "sim_smart.init_smarts_list")
  add_dialog(1, 22, gs("st_sim_smart_dialog_4"), nil, "sim_smart.init_levels_list")
  add_dialog(1, 4, gs("st_sim_smart_dialog_5"))
  add_dialog(4, 5, gs("st_sim_smart_dialog_6"))
  add_dialog(2, 3, gs("st_sim_smart_dialog_7"))
  add_dialog(22, 33, gs("st_sim_smart_dialog_8"))

  add_dialog(5, 903, gs("st_sim_smart_dialog_9"), nil, "sim_smart.spawn_defense")
  add_dialog(5, 904, gs("st_sim_smart_dialog_10"))

  add_script_dialog(3, 900, "sim_smart.textinfo")
  add_script_dialog(33, 300, "sim_smart.textinfo")

  add_script_dialog(33, 3001, "sim_smart.txt1", "sim_smart.condition_item_1", "sim_smart.page_item_1")
  add_script_dialog(33, 3002, "sim_smart.txt2", "sim_smart.condition_item_2", "sim_smart.page_item_2")
  add_script_dialog(33, 3003, "sim_smart.txt3", "sim_smart.condition_item_3", "sim_smart.page_item_3")
  add_script_dialog(33, 3004, "sim_smart.txt4", "sim_smart.condition_item_4", "sim_smart.page_item_4")
  add_script_dialog(33, 3005, "sim_smart.txt5", "sim_smart.condition_item_5", "sim_smart.page_item_5")

  add_script_dialog(3, 9001, "sim_smart.txt1", "sim_smart.condition_item_1", "sim_smart.page_item_1")
  add_script_dialog(3, 9002, "sim_smart.txt2", "sim_smart.condition_item_2", "sim_smart.page_item_2")
  add_script_dialog(3, 9003, "sim_smart.txt3", "sim_smart.condition_item_3", "sim_smart.page_item_3")
  add_script_dialog(3, 9004, "sim_smart.txt4", "sim_smart.condition_item_4", "sim_smart.page_item_4")
  add_script_dialog(3, 9005, "sim_smart.txt5", "sim_smart.condition_item_5", "sim_smart.page_item_5")

  add_dialog(3001, 33, "")
  add_dialog(3002, 33, "")
  add_dialog(3003, 33, "")
  add_dialog(3004, 33, "")
  add_dialog(3005, 33, "")

  add_dialog(9001, 3, "")
  add_dialog(9002, 3, "")
  add_dialog(9003, 3, "")
  add_dialog(9004, 3, "")
  add_dialog(9005, 3, "")

  add_dialog(33, 301, "axr_phrase_sim_smart_start_option_1_phrase_2", nil, "sim_smart.prev_item_page")
  add_dialog(33, 302, "axr_phrase_sim_smart_start_option_2_phrase_3", nil, "sim_smart.next_item_page")
  add_dialog(301, 33, "axr_phrase_sim_smart_start_prev_five")

  add_dialog(302, 33, "axr_phrase_sim_smart_start_next_five")
  add_dialog(33, 398, gs("st_sim_smart_dialog_10"))

  add_dialog(3, 901, "axr_phrase_sim_smart_start_option_1_phrase_1", nil, "sim_smart.prev_item_page")
  add_dialog(3, 902, "axr_phrase_sim_smart_start_option_2_phrase_1", nil, "sim_smart.next_item_page")
  add_dialog(901, 3, "axr_phrase_sim_smart_start_prev_five")

  add_dialog(902, 3, "axr_phrase_sim_smart_start_next_five")
  add_dialog(3, 998, gs("st_sim_smart_dialog_10"))

  add_dialog(1, 999, gs("st_sim_smart_dialog_11"))
end

function set_max_population(smart)
  if (smart.props) then
    smart.max_population = 10

    if isLair(smart) then
      smart.max_population = 8
    elseif isBase(smart) then
      smart.max_population = sim_brain.check_individual_smart_pop(smart)
    end
  end
end

function get_smart_global_position(smart)
  local offset = sim_tables.level_offsets[smart.level_id] or {0, 0, 0}
  local p = smart.position

  smart.global_position = vector():set(p.x + offset[1], p.y + offset[2], p.z + offset[3])

  return smart.global_position
end

function smart_terrain_on_update(smart)
  local curr_time = game.get_game_time()
  smart.last_respawn_update = curr_time

  if not (smart.level_id) then
    smart.level_id = game_graph():vertex(smart.m_game_vertex_id):level_id()
  end

  if not (smart.first_update) then
    smart.first_update = true

    set_max_population(smart)

    if (smart_owners[smart.id]) then
      smart.owning_faction = smart_owners[smart.id]
    end

    if not smart.global_position then
      smart.global_position = get_smart_global_position(smart)
    end
  end

  check_owner(smart)

  if not smart.target_smarts then
    smart.target_smarts = {}
  end

  if not smart.target_smart_count then
    smart.target_smart_count = 0
  end

  if not sim_brain.initialized then
    return
  end

  local faction = smart.owning_faction
  local dist = alife():actor().position:distance_to_sqr(smart.position)

  if smart.props then
    if dist < 1000 and smart_has_live_leader(smart) then
      local relation = game_relations.get_factions_community(faction, sim_brain.actor_faction)
      if relation < -1200 then
        spawn_defense_leader_squad(smart)
      end
    end
    if dist > 20000 then
      smart_control(smart)
    end

    process_mutants(smart)

    if isBase(smart) or isCamp(smart) then
      if isBase(smart) then
        set_targets(smart)
      end

      local respawn_factions = axr_main.config:r_value("mm_options", "enable_respawn_factions", 1, true)

      if sim_brain.initialized and faction == "none" and respawn_factions and isBase(smart) then
        try_to_respawn_faction(smart)
      elseif faction ~= "none" then
        local disable_spawn_attack = axr_main.config:r_value("mm_options", "enable_disable_spawn_attack", 1, false)
        local behavior = axr_main.config:r_value("mm_options", "behavior_" .. faction, 0, "proffi")

        spawn_defense_squad(smart)

        if not (disable_spawn_attack) and not isCamp(smart) and behavior ~= "passive" then
          spawn_attack_squad(smart)
        end

        if faction ~= "zombied" and faction ~= "monster" then
          check_npc(smart)
        end
      end
    elseif isLair(smart) then
      local spawn_mutants_enable = axr_main.config:r_value("mm_options", "enable_spawn_mutants", 1, true)
      if spawn_mutants_enable and faction == "none" and dist > 20000 then
        spawn_mutants(smart)
      end
    else
      if faction ~= "zombied" and faction ~= "none" and faction ~= "monster" then
        check_npc(smart)
      end
    end
  end

  sim_smart_capture.smart_terrain_on_update(smart)
end

function try_to_respawn_faction(smart)
  if not (respawn_timers[smart.id]) then
    respawn_timers[smart.id] = game.get_game_time()
    respawn_next_update[smart.id] = 200
    return
  elseif (game.get_game_time():diffSec(respawn_timers[smart.id]) > (respawn_next_update[smart.id] * 30)) then
    respawn_timers[smart.id] = game.get_game_time()
    respawn_next_update[smart.id] = 200
  else
    return
  end

  local smart_level = alife():level_name(game_graph():vertex(smart.m_game_vertex_id):level_id())

  for i, faction in pairs(sim_tables.factions) do
    if faction ~= "monster" then
      local faction_can_be_respawned = axr_main.config:r_value("mm_options", "enable_respawn_" .. faction, 1, true)

      if
        sim_factions.faction_information[faction].base_count and
          sim_factions.faction_information[faction].base_count < 1 and
          faction_can_be_respawned
       then
        local level_chk = sim_brain.allowed_respawn(smart_level, faction)

        if level_chk == true then
          sim_factions.faction_information[faction].base_count =
            sim_factions.faction_information[faction].base_count + 1
          sim_squad.create_squad(smart, faction, nil, nil, nil, 1)
          return
        end
      end
    end
  end
end

function spawnTraderOnSmart(smart)
  if uniqueSmarts[smart:name()] then
    uniqueSmarts[smart:name()][1] = 1
  else
    uniqueSmarts[smart:name()] = {1, 0, 0, 0, 0}
  end
  check_npc(smart, 0)
  unique_check_next_update[smart.id] = 0
end

function spawnMechanicOnSmart(smart)
  if uniqueSmarts[smart:name()] then
    uniqueSmarts[smart:name()][2] = 1
  else
    uniqueSmarts[smart:name()] = {0, 1, 0, 0, 0}
  end
  check_npc(smart, 0)
  unique_check_next_update[smart.id] = 0
end

function check_npc(smart, customTime)
  if
    not (unique_check_timers[smart.id]) or
      (game.get_game_time():diffSec(unique_check_timers[smart.id]) > (unique_check_next_update[smart.id] * 60))
   then
    unique_check_timers[smart.id] = game.get_game_time()
    unique_check_next_update[smart.id] = sim_factions.faction_information[smart.owning_faction].respawn_unique

    if customTime ~= nil then
      unique_check_next_update[smart.id] = customTime
    end
  else
    return
  end

  local faction = smart.owning_faction
  local trader = faction .. "_sim_squad_trader"
  local mechanic = faction .. "_sim_squad_mechanic"
  local barmen = faction .. "_sim_squad_barmen"
  local medik = faction .. "_sim_squad_medik"
  local unik = faction .. "_sim_squad_unik"
  local explorer = faction .. "_sim_squad_explorer"
  local dist = alife():actor().position:distance_to_sqr(smart.position)
  local relation = game_relations.get_factions_community(faction, sim_brain.actor_faction)

  if relation < -100 and dist < 9000 then
    return
  end

  local enable_spawn_explorers = axr_main.config:r_value("mm_options", "enable_spawn_explorers", 1, true)

  if enable_spawn_explorers and (isBase(smart) or isCamp(smart)) then
    local explorer_in_smart = 0
    local squads = SIMBOARD.smarts[smart.id].squads

    for _, s in pairs(squads) do
      if string.match(s:name(), "explorer") then
        explorer_in_smart = explorer_in_smart + 1
      end
    end

    if explorer_in_smart == 0 then
      sim_squad.create_squad(smart, faction, nil, explorer, nil, 1)
    end
  end

  if (uniqueSmarts[smart:name()]) then
    local tbl = uniqueSmarts[smart:name()]
    local trader_pop = tbl[1]
    local mechanic_pop = tbl[2]
    local barmen_pop = tbl[3]
    local medik_pop = tbl[4]
    local unik_pop = tbl[5]

    local mechanic_in_smart = 0
    local trader_in_smart = 0
    local medik_in_smart = 0
    local barmen_in_smart = 0
    local unik_in_smart = 0

    local squads = SIMBOARD.smarts[smart.id].squads

    for _, s in pairs(squads) do
      if string.match(s:name(), "mechanic") or string.match(s:name(), "tech") or string.match(s:name(), "drunk") then
        mechanic_in_smart = mechanic_in_smart + 1
      elseif string.match(s:name(), "trader") or string.match(s:name(), "petrenko") then
        trader_in_smart = trader_in_smart + 1
      elseif string.match(s:name(), "barmen") then
        barmen_in_smart = barmen_in_smart + 1
      elseif string.match(s:name(), "medik") or string.match(s:name(), "medic") or string.match(s:name(), "doctor") then
        medik_in_smart = medik_in_smart + 1
      elseif string.match(s:name(), "unik") then
        unik_in_smart = unik_in_smart + 1
      end
    end

    local createdSquad = nil
    while mechanic_in_smart < mechanic_pop do
      createdSquad = sim_squad.create_squad(smart, faction, nil, mechanic, nil, 1)
      mechanic_in_smart = mechanic_in_smart + 1
    end

    while trader_in_smart < trader_pop do
      createdSquad = sim_squad.create_squad(smart, faction, nil, trader, nil, 1)
      trader_in_smart = trader_in_smart + 1
    end

    while barmen_in_smart < barmen_pop do
      createdSquad = sim_squad.create_squad(smart, faction, nil, barmen, nil, 1)
      barmen_in_smart = barmen_in_smart + 1
    end

    while medik_in_smart < medik_pop do
      createdSquad = sim_squad.create_squad(smart, faction, nil, medik, nil, 1)
      medik_in_smart = medik_in_smart + 1
    end

    while unik_in_smart < unik_pop do
      createdSquad = sim_squad.create_squad(smart, faction, nil, unik, nil, 1)
      unik_in_smart = unik_in_smart + 1
    end
  end
end

-- TODO: ��������������. ��������� npc_count > smart.max_population ����� ������� ������
function smart_control(smart)
  local tg = time_global()
  if smart.last_npc_check ~= nil and tg < smart.last_npc_check then
    return
  end
  smart.last_npc_check = tg + 30000
  local squads = SIMBOARD.smarts[smart.id].squads
  for _, squad in pairs(squads) do
    local faction = squad:get_squad_community()

    if squad.registered_in_simultaion and squad.current_action == 1 then
      local npc_count = npc_count_passive(smart, faction)

      if
        (faction ~= smart.owning_faction and not game_relations.is_factions_enemies(faction, smart.owning_faction) and
          faction ~= sim_brain.actor_faction)
       then
        if smart.owning_faction ~= "none" and squad.scripted_target ~= "actor" then
          utils.debug("squad change own target, squad: %s", squad:name())
          sim_squad.remove_squad(squad)
        end
      end

      if
        (npc_count > smart.max_population) and
          (string.find(squad:name(), "veteran") or string.find(squad:name(), "master") or
            string.find(squad:name(), "advanced") or
            string.find(squad:name(), "nachunaushu") or
            string.find(squad:name(), "novnachun") or
            string.find(squad:name(), "novadvan") or
            string.find(squad:name(), "advanvet") or
            string.find(squad:name(), "vetmas") or
            string.find(squad:name(), "rybech") or
            string.find(squad:name(), "advanced") or
            string.find(squad:name(), "legenda") or
            string.find(squad:name(), "masleg") or
            string.find(squad:name(), "zelnov") or
            string.find(squad:name(), "zelen") or
            string.find(squad:name(), "novice"))
       then
        local squad_npcs = {}

        if squad.current_action == 1 then
          for k in squad:squad_members() do
            squad_npcs[#squad_npcs + 1] = k
          end

          local k1 = squad_npcs[math.random(#squad_npcs)]

          if (k1) then
            squad:remove_npc(k1.id)
          end

          printf("### ���: -- smart_control 2 -- " .. squad:name() .. " - " .. smart:name() .. " ###")
        end
      end
    end
  end
end

function set_targets(smart)
  local tg = time_global()

  if smart.set_targets ~= nil and tg < smart.set_targets then
    return
  end

  smart.set_targets = tg + 10000

  local behavior = axr_main.config:r_value("mm_options", "behavior_" .. smart.owning_faction, 0, "proffi")

  if behavior == "passive" then
    return
  end

  local target_smart_count = 0
  for target, _ in pairs(smart.target_smarts) do
    local other = alife_object(target)

    if other and other.owning_faction then
      local relation = game_relations.get_factions_community(smart.owning_faction, other.owning_faction)

      if (other.owning_faction ~= "none" and relation and relation >= 0) then
        smart.target_smarts[other.id] = nil
      else
        target_smart_count = target_smart_count + 1
      end
    end
  end

  if (target_smart_count < 3) then
    local targets = gm_find_tardets_for_smarts.find_targets(smart)

    if targets and (#targets > 0) then
      for i = 1, #targets do
        if not smart.target_smarts[targets[i][2]] then
          smart.target_smarts[targets[i][2]] = true
          return
        end
      end
    end
  end
end

function spawn_defense_leader_squad(smart)
  if spawned_leaders_squads[smart.id] then
    return
  end

  local squad_count_by_difficulty = {
    [0] = 1,
    [1] = 2,
    [2] = 3,
    [3] = 4
  }
  local difficulty = level.get_game_difficulty()

  for i = 1, squad_count_by_difficulty[difficulty] or 2 do
    local section = smart.owning_faction .. "_sim_squad_legend"
    local squad = alun_utils.create_squad(section, smart:name())
  end

  spawned_leaders_squads[smart.id] = true
end

function spawn_defense_squad(smart)
  if
    not (defense_timers[smart.id]) or
      (game.get_game_time():diffSec(defense_timers[smart.id]) > (defense_next_update[smart.id] * 60))
   then
    defense_timers[smart.id] = game.get_game_time()
    defense_next_update[smart.id] = sim_factions.faction_information[smart.owning_faction].respawn_defend
  else
    return
  end

  local smart_type_name = utils.get_smart_type_name(smart)
  local squad_limit = smart_spawn_limit[smart_type_name]
  local squad_count = squad_count_passive(smart)

  if squad_count >= squad_limit then
    return
  end

  local faction = smart.owning_faction
  local npc_in_smart = npc_count_passive(smart, faction)

  local fi = sim_factions.faction_information[smart.owning_faction]

  if (fi) then
    if (fi.faction_passive_npc_limit > fi.passive_npc) or (smart.props.camp > 0) then
      if npc_in_smart < smart.max_population then
        sim_squad.create_squad(smart, faction, nil, nil, nil, 1)
      end
    end
  end
end

function spawn_attack_squad(smart)
  local disable_spawn_attack = axr_main.config:r_value("mm_options", "enable_disable_spawn_attack", 1, false)

  if
    not (attack_timers[smart.id]) or
      ((game.get_game_time():diffSec(attack_timers[smart.id]) > (attack_next_update[smart.id] * 60)) and
        not disable_spawn_attack)
   then
    attack_timers[smart.id] = game.get_game_time()
    attack_next_update[smart.id] = sim_factions.faction_information[smart.owning_faction].respawn_attack
  else
    return
  end

  local night = (level.get_time_hours() < 6 or level.get_time_hours() > 20)
  local actor_faction = sim_brain.actor_faction
  local faction = smart.owning_faction

  if (night and math.random(100) > 80) then
    return
  end

  local target = nil

  if actor_faction == faction and hasAnyPriority() then
    local smart_id = popMaxPriority()

    if smart_id ~= nil then
      target = smart_id and alife_object(smart_id)
    end
  end

  if target == nil then
    local smart_id = utils.get_random_item_table(smart.target_smarts, true)

    target = smart_id and alife_object(smart_id)
  end

  if target == nil then
    for t, _ in pairs(smart.target_smarts) do
      local other = t and alife_object(t)

      if other and not target then
        if squad_count(other, smart.owning_faction) < 3 then
          target = other
        end
      end
    end
  end

  local squad
  if target then
    squad = sim_squad.create_squad(smart, faction, target, nil, nil, 1)
  end

  if not squad and (hunt_by_actor_time[faction] or hunt_by_actor_infinity[faction]) then
    squad = sim_squad.create_squad(smart, faction, target, nil, nil, 1)
  end

  if hunt_by_actor_infinity[faction] and IsSquad(squad) then
    gm_actor_hunter.addToHunters(squad)
    return
  end

  utils.debug(
    "sim_smart.spawn_attack_squad, squad=[%s] faction=[%s] hunt_by_actor_time=[%s] get_game_time=[%s] diffSec=[%s]",
    squad and squad:name(),
    faction,
    hunt_by_actor_time[faction],
    game.time(),
    hunt_by_actor_time[faction] and hunt_by_actor_time[faction] > game.time()
  )
  if hunt_by_actor_time[faction] and hunt_by_actor_time[faction] > game.time() and IsSquad(squad) then
    gm_actor_hunter.addToHunters(squad)
  end
end

function spawn_mutants(smart)
  if
    not (mutant_timers[smart.id]) or
      (game.get_game_time():diffSec(mutant_timers[smart.id]) > (mutant_next_update[smart.id] * 60))
   then
    mutant_timers[smart.id] = game.get_game_time()
    mutant_next_update[smart.id] = 70
  else
    return
  end

  local enable_global_mutants_settings =
    axr_main.config:r_value("mm_options", "enable_global_mutants_settings", 1, true)
  local mutants_squad_count = axr_main.config:r_value("mm_options", "mutants_squad_count", 2, 1)
  if mutants_squad_count and mutants_squad_count > 12 then mutants_squad_count = 12 end
  local mutants_on_level = sim_offline_control.get_num_squads_on_level(smart.level_id, "monster")
  local level = alife():level_name(game_graph():vertex(smart.m_game_vertex_id):level_id())
  local enable_spawn_mutants_level = axr_main.config:r_value("mm_options", "enable_spawn_mutants_on_" .. level, 1, true)
  local section
  local count = mutants_on_level ~= 0 and mutants_on_level or mutants_by_level[level] or 0
  if not enable_global_mutants_settings then
    mutants_squad_count = axr_main.config:r_value("mm_options", "mutants_squad_count_on_" .. level, 2, 1)
    if mutants_squad_count and mutants_squad_count > 12 then mutants_squad_count = 12 end
  end

  if not enable_spawn_mutants_level then
    return
  end

  if level == "l12u_control_monolith" or level == "l12u_sarcofag" or level == "l11_hospital" then
    return
  end

  if count < mutants_squad_count then
    local opt_key = strformat("mutants_level_%s_list", level)
    local mutants_level = axr_main.config:r_value("mm_options", opt_key, 3, {})

    section = mutants_level[math.random(#mutants_level)]

    if section then
      local squad = sim_squad.create_squad(smart, nil, nil, section, nil, 1)
      mutants_by_level[level] = (mutants_by_level[level] or 0) + 1
      if squad and sim_offline_control.squads_by_level and sim_offline_control.squads_by_level[smart.level_id] then
        sim_offline_control.squads_by_level[smart.level_id][squad.id] = true
      end
    end

    if mutants_squad_count == 20 then
      mutants_squad_count = 12
      local squad = sim_squad.create_squad(smart, nil, nil, "simulation_zombie", nil, 1)
      if squad and sim_offline_control.squads_by_level and sim_offline_control.squads_by_level[smart.level_id] then
        sim_offline_control.squads_by_level[smart.level_id][squad.id] = true
      end
    end
  end
end

function process_mutants(smart)
  local tg = time_global()

  if smart.process_mutants ~= nil and tg < smart.process_mutants then
    return
  end

  smart.process_mutants = tg + 30000

  local squads = SIMBOARD.smarts[smart.id].squads
  local night = (level.get_time_hours() < 6 or level.get_time_hours() > 20)
  local level_info = sim_levels.level_information[smart.level_id]

  for _, squad in pairs(squads) do
    if squad:get_squad_community() == "monster" then
      for _, sm in pairs(level_info.smarts) do
        if squad.arrive_time and squad.wait_time and game.get_game_time():diffSec(squad.arrive_time) >= squad.wait_time then
          local other = sm and alife_object(sm)
          if (other and other.props) then
            if (night) then
              if math.random(100) > 50 then
                if (other.owning_faction ~= "none") then
                  sim_squad.set_target(squad, sm)
                  return
                end
              else
                if (other.owning_faction == "none") then
                  local mutants_in_target = squad_count(other, "monster")

                  if mutants_in_target < 1 then
                    sim_squad.set_target(squad, sm)
                    return
                  end
                end
              end
            else
              if (other.owning_faction == "none") then
                local mutants_in_target = squad_count(other, "monster")

                if mutants_in_target < 1 then
                  sim_squad.set_target(squad, sm)
                  return
                end
              end
            end
          end
        end
      end
    end
  end
end

function smart_terrain.se_smart_terrain.show(self)
  local faction = self.owning_faction
  local level_id = game_graph():vertex(self.m_game_vertex_id):level_id()

  if utils.table_has_item(sim_tables.labs, level_id) then
    return
  end

  local smartType = utils.get_smart_type_name(self)
  local spotSize = axr_main.config:r_value("mm_options", "pda_smart_icons_size", 2, 24)
  local spotType = axr_main.config:r_value("mm_options", "pda_smart_icons_color", 2, 0)
  local colorEnable =
    axr_main.config:r_value("mm_options", strformat("enable_pda_smart_%s_enabled_color", smartType), 1, false)
  local spotTypeName = getSenderPdaIcon(faction, self)

  if (self.simulation_spot) then
    if self.simulation_spot ~= faction then
      level.map_set_object_spot(self.id, spotTypeName, get_simulation_info(self))
      self.simulation_spot = faction
    else
      level.map_change_spot_hint(self.id, spotTypeName, get_simulation_info(self))
    end
  else
    level.map_set_object_spot(self.id, spotTypeName, get_simulation_info(self))
    self.simulation_spot = faction
  end

  level.map_change_spot_size(self.id, spotTypeName, spotSize, spotSize)
  if faction == "none" then
    local noneType = strformat("icons\\empty_smarts\\%s_%s", smartType, spotType)
    level.map_change_spot_texture(self.id, spotTypeName, noneType)

    if colorEnable then
      local r = axr_main.config:r_value("mm_options", strformat("pda_smart_%s_color_r", smartType), 2, 255)
      local g = axr_main.config:r_value("mm_options", strformat("pda_smart_%s_color_g", smartType), 2, 255)
      local b = axr_main.config:r_value("mm_options", strformat("pda_smart_%s_color_b", smartType), 2, 255)
      level.map_change_spot_color(self.id, spotTypeName, GetARGB(255, r, g, b))
    else
      level.map_change_spot_color(self.id, spotTypeName, GetARGB(255, 255, 255, 255))
    end
  end
end

function get_simulation_info(smart)
  local sim_name = gs(smart:name())
  local npc_in_smart = npc_count(smart, smart.owning_faction)
  local props = ""
  local type = ""

  if (sim_name) then
    if DEV_DEBUG then
      props = strformat("\\n%s (%s)\\n", sim_name, smart:name())
    else
      props = strformat("\\n%s\\n", sim_name)
    end
  else
    props = "\\n" .. smart:name() .. "\\n"
  end

  if DEV_DEBUG then
    props = string.format("%s\\nID: %s\\n", props, smart.id)
  end

  if isBase(smart) then
    type = gs("base")
  elseif isResource(smart) then
    type = gs("resource")
  elseif isTerritory(smart) then
    type = gs("territory")
  elseif isLair(smart) then
    type = gs("lair")
  elseif isCamp(smart) then
    type = gs("camp")
  elseif isPoint(smart) then
    type = gs("point")
  end

  if smart.owning_faction == "none" then
    props = props .. "\\n" .. type .. "\\n"
  else
    props =
      props ..
      "\\n" ..
        type .. gs("st_sim_smart_smart_under_faction") .. " " .. gs("st_faction_" .. smart.owning_faction) .. "\\n"

    local factionRelation = ""
    local relation = game_relations.get_factions_community(smart.owning_faction, alife():actor():community())

    if (relation) then
      if relation >= 3000 then
        factionRelation =
          "%c[255,0,255,0]\\n" ..
          gs("st_sim_smart_relation") .. ": " .. gs("st_sim_smart_relation_aa") .. "\\n%c[default]"
      elseif relation >= 1000 and relation < 3000 then
        factionRelation =
          "%c[255,0,255,0]\\n" ..
          gs("st_sim_smart_relation") .. ": " .. gs("st_sim_smart_relation_a") .. "\\n%c[default]"
      elseif relation >= -500 and relation < 1000 then
        factionRelation =
          "%c[255,255,255,0]\\n" ..
          gs("st_sim_smart_relation") .. ": " .. gs("st_sim_smart_relation_n") .. "\\n%c[default]"
      elseif relation < -500 and relation > -1000 then
        factionRelation =
          "%c[255,255,0,0]\\n" ..
          gs("st_sim_smart_relation") .. ": " .. gs("st_sim_smart_relation_nf") .. "\\n%c[default]"
      elseif relation < -1000 and relation > -3000 then
        factionRelation =
          "%c[255,255,0,0]\\n" ..
          gs("st_sim_smart_relation") .. ": " .. gs("st_sim_smart_relation_ff") .. "\\n%c[default]"
      elseif relation <= -3000 then
        factionRelation =
          "%c[255,255,0,0]\\n" ..
          gs("st_sim_smart_relation") .. ": " .. gs("st_sim_smart_relation_ffff") .. "\\n%c[default]"
      end
    else
      if game_relations.is_factions_friends(smart.owning_faction, alife():actor():community()) then
        factionRelation =
          "%c[255,0,255,0]\\n" ..
          gs("st_sim_smart_relation") .. ": " .. gs("st_sim_smart_relation_1_a") .. "\\n%c[default]"
      elseif game_relations.is_factions_neutrals(smart.owning_faction, alife():actor():community()) then
        factionRelation =
          "%c[255,255,255,0]\\n" ..
          gs("st_sim_smart_relation") .. ": " .. gs("st_sim_smart_relation_1_n") .. "\\n%c[default]"
      elseif game_relations.is_factions_enemies(smart.owning_faction, alife():actor():community()) then
        factionRelation =
          "%c[255,255,0,0]\\n" ..
          gs("st_sim_smart_relation") .. ": " .. gs("st_sim_smart_relation_1_f") .. "\\n%c[default]"
      end
    end

    props = props .. "\\n" .. factionRelation .. "\\n"

    if smart.owning_faction == sim_brain.actor_faction then
      props =
        strformat(
        "%s\\n" .. gs("st_sim_smart_squad_count") .. " " .. "%s\\n",
        props,
        get_squad_count_without_unique(smart, sim_brain.actor_faction)
      )
    end

    if npc_in_smart <= 2 then
      props = props .. "\\n" .. gs("st_sim_smart_def_level_ff") .. " \\n"
    elseif npc_in_smart > 2 and npc_in_smart <= 4 then
      props = props .. "\\n" .. gs("st_sim_smart_def_level_f") .. " \\n"
    elseif npc_in_smart > 4 and npc_in_smart <= 7 then
      props = props .. "\\n" .. gs("st_sim_smart_def_level_n") .. " \\n"
    elseif npc_in_smart > 7 and npc_in_smart <= 17 then
      props = props .. "\\n" .. gs("st_sim_smart_def_level_a") .. " \\n"
    elseif npc_in_smart > 17 and npc_in_smart <= 25 then
      props = props .. "\\n" .. gs("st_sim_smart_def_level_aa") .. " \\n"
    elseif npc_in_smart > 25 then
      props = props .. "\\n" .. gs("st_sim_smart_def_level_close") .. " \\n"
    end
  end

  local f = false
  smart.target_smarts = smart.target_smarts or {}
  for target, _ in pairs(smart.target_smarts) do
    if not (f) then
      f = true
      props = props .. "\\n" .. gs("st_sim_smart_targets") .. "\\n"
    end

    local other = alife_object(target)

    if (other) then
      local otherGreatWar = gs(other:name())
      props = props .. "\\n" .. otherGreatWar .. "\\n"
    end
  end

  local disable_spawn_attack = axr_main.config:r_value("mm_options", "enable_disable_spawn_attack", 1, false)

  if
    smart.props.base > 0 and attack_next_update[smart.id] ~= nil and attack_timers[smart.id] ~= nil and
      not disable_spawn_attack
   then
    props =
      props ..
      "\\n\\n" ..
        gs("st_sim_smart_attack_squad_timer") ..
          " " .. ((attack_next_update[smart.id] * 60) - (game.get_game_time():diffSec(attack_timers[smart.id]))) / 60
  end

  if
    (smart.props.base > 0 or smart.props.camp > 0) and defense_next_update[smart.id] ~= nil and
      defense_timers[smart.id] ~= nil
   then
    props =
      props ..
      "\\n\\n" ..
        gs("st_sim_smart_def_squad_timer") ..
          " " .. ((defense_next_update[smart.id] * 60) - (game.get_game_time():diffSec(defense_timers[smart.id]))) / 60
  end

  if smart.props.lair > 0 and mutant_next_update[smart.id] ~= nil and mutant_timers[smart.id] ~= nil then
    props =
      props ..
      "\\n\\n" ..
        gs("st_sim_smart_mutant_squad_timer") ..
          " " .. ((mutant_next_update[smart.id] * 60) - (game.get_game_time():diffSec(mutant_timers[smart.id]))) / 60
  end

  return props
end

function rerender_smart_icons()
  if pda_smart_icons_size_old == pda_smart_icons_size_new and pda_smart_icons_color_old == pda_smart_icons_color_new then
    return
  end
  if not SIMBOARD then
    return
  end

  local spotSize = axr_main.config:r_value("mm_options", "pda_smart_icons_size", 2, 24)
  local spotType = axr_main.config:r_value("mm_options", "pda_smart_icons_color", 2, 0)

  for _, smart in pairs(SIMBOARD.smarts_by_names) do
    local faction = smart.owning_faction
    local level_id = game_graph():vertex(smart.m_game_vertex_id):level_id()
    local smartType = utils.get_smart_type_name(smart)
    local colorEnable =
      axr_main.config:r_value("mm_options", strformat("enable_pda_smart_%s_enabled_color", smartType), 1, false)

    if smart.simulation_spot and not utils.table_has_item(sim_tables.labs, level_id) then
      local new_icon_id = getSenderPdaIcon(faction, smart)

      level.map_set_object_spot(smart.id, new_icon_id, get_simulation_info(smart))
      level.map_change_spot_size(smart.id, new_icon_id, spotSize, spotSize)
      if smart.owning_faction == "none" then
        local noneType = strformat("icons\\empty_smarts\\%s_%s", smartType, spotType)
        level.map_change_spot_texture(smart.id, new_icon_id, noneType)

        if colorEnable then
          local r = axr_main.config:r_value("mm_options", strformat("pda_smart_%s_color_r", smartType), 2, 255)
          local g = axr_main.config:r_value("mm_options", strformat("pda_smart_%s_color_g", smartType), 2, 255)
          local b = axr_main.config:r_value("mm_options", strformat("pda_smart_%s_color_b", smartType), 2, 255)
          level.map_change_spot_color(smart.id, new_icon_id, GetARGB(255, r, g, b))
        else
          level.map_change_spot_color(smart.id, new_icon_id, GetARGB(255, 255, 255, 255))
        end
      end
    end

    smart:update()
  end
end
function squad_count(smart, faction)
  if not smart.owning_faction then
    smart.owning_faction = "none"
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local squad_count = 0

  for i, squad in pairs(squads) do
    if
      (faction and squad.registered_in_simultaion and squad:get_squad_community() == faction and
        squad.current_action == 1) or
        (not faction and squad.registered_in_simultaion and squad.current_action == 1)
     then
      squad_count = squad_count + 1
    end
  end

  return squad_count
end

function squad_count_passive(smart, faction)
  if not faction then
    faction = smart.owning_faction
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local count = 0

  for i, squad in pairs(squads) do
    if (squad.registered_in_simultaion and squad:get_squad_community() == faction and squad.current_action == 1) then
      count = count + 1
    end
  end

  return count
end

function npc_count(smart, faction)
  if not (smart.owning_faction) then
    smart.owning_faction = "none"
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local npc_count = 0

  for i, squad in pairs(squads) do
    if
      ((squad.registered_in_simultaion and squad.current_action == 1 and faction == nil) or
        (squad.registered_in_simultaion and squad.current_action == 1 and faction and
          squad:get_squad_community() == faction))
     then
      local npc_in_squad = squad:npc_count()
      npc_count = npc_count + npc_in_squad
    end
  end

  return npc_count
end

function get_squad_count(smart)
  local count = 0

  for i, squad in pairs(SIMBOARD.smarts[smart.id].squads) do
    if (squad.registered_in_simultaion) then
      count = count + 1
    end
  end

  return count
end

function get_squad_count_without_unique(smart, faction)
  local count = 0

  for _, squad in pairs(SIMBOARD.smarts[smart.id].squads) do
    if (squad.registered_in_simultaion) and not IsUniqSquad(squad) then
      if faction then
        if squad:get_squad_community() == faction and squad.current_action == 1 then
          count = count + 1
        end
      else
        count = count + 1
      end
    end
  end

  return count
end

function npc_count_passive(smart, faction)
  if not (smart.owning_faction) then
    smart.owning_faction = "none"
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local npc_count = 0

  for i, squad in pairs(squads) do
    if (squad.registered_in_simultaion and squad:get_squad_community() == faction and squad.current_action == 1) then
      local npc_in_squad = squad:npc_count()
      npc_count = npc_count + npc_in_squad
    end
  end

  return npc_count
end

function npc_count_active(smart, faction)
  if not (smart.owning_faction) then
    smart.owning_faction = "none"
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local npc_count = 0

  for i, squad in pairs(squads) do
    if (squad.registered_in_simultaion and squad:get_squad_community() == faction and squad.current_action == 0) then
      local npc_in_squad = squad:npc_count()
      npc_count = npc_count + npc_in_squad
    end
  end

  return npc_count
end

function smart_has_live_leader(smart)
  if not smart.owning_faction or smart.owning_faction == "none" then
    return false
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local npc_count = 0

  for i, squad in pairs(squads) do
    if IsLeaderSquad(squad) then
      return true
    end
  end
end

function check_owner(smart)
  if not smart then
    return
  end

  if smart.time_to_capture then
    smart.owning_faction = "none"
    return
  end

  if not SIMBOARD.smarts[smart.id] then
    smart.owning_faction = "none"
    return
  end

  if not SIMBOARD.smarts[smart.id].squads then
    smart.owning_faction = "none"
    return
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local squadCount = {}
  local squadPowers = {}

  if not smart.owning_faction then
    smart.owning_faction = "none"
  end

  local smart_type_name = utils.get_smart_type_name(smart)
  local squad_limit = smart_spawn_limit[smart_type_name]
  local squad_count = squad_count_passive(smart)

  if squad_count > squad_limit then
    local count = 1
    for _, squad in pairs(squads) do
      if not IsUniqSquad(squad) then
        if count > squad_limit and squad.registered_in_simultaion and squad.current_action == 1 then
          sim_squad.remove_squad(squad)
        end

        count = count + 1
      end
    end
  end

  for _, squad in pairs(squads) do
    local faction = squad:get_squad_community()

    if squad.current_action == 1 and squad.registered_in_simultaion then
      if not squadCount[faction] then
        squadCount[faction] = 0
        squadPowers[faction] = 0
      end

      local power = sim_offline_control.ocs_power_table[squad.id]

      if power and power > 0 then
        squadPowers[faction] = squadPowers[faction] + power
      end

      squadCount[faction] = squadCount[faction] + 1
    end

    if faction ~= "trader" and IsUniqSquad(squad) then
      if not squadCount[faction] then
        squadCount[faction] = 0
        squadPowers[faction] = 0
      end

      if IsLeaderSquad(squad) then
        squadCount[faction] = squadCount[faction] + 100
      end

      squadCount[faction] = squadCount[faction] + 1
    end
  end

  local owner = "none"
  for faction, count in pairs(squadCount) do
    if squadCount[faction] > 99 then
      owner = faction
    elseif owner == "none" or faction == smart.owning_faction then
      owner = faction
    elseif (squadCount[owner] < count and smart.owning_faction == "none") then
      owner = faction
    end
  end

  if owner == "monster" then
    owner = "none"
  end

  smart.defense_count = squadCount[owner] or 0
  smart.defense_power = squadPowers[owner] or 0

  if not smart.last_owner then
    smart.last_owner = owner
  end

  if smart.last_owner ~= smart.owning_faction then
    sim_offline_to_online.switch_control_news(smart)
  end

  if (smart.last_owner) then
    smart.last_owner = smart.owning_faction
  end

  smart.owning_faction = owner
end

function get_nearest_base(smart, faction, collection)
  if not IsSmart(smart) then
    return
  end
  if not faction or faction == "none" then
    return
  end

  local targets = {}

  for i = 1, #collection do
    local other = alife_object(collection[i])

    if isBase(other) and other.owning_faction == faction then
      local dist = smart.global_position:distance_to_sqr(other.global_position)

      targets[#targets + 1] = {
        math.abs(dist),
        other.id,
        gs(other:name())
      }
    end
  end

  targets = sim_brain.sort_priority_table(targets)

  return targets[1] and targets[1][2], targets[1] and targets[1][3]
end
function get_nearest_base_on_other_levels(smart, faction)
  if not IsSmart(smart) then
    return
  end
  if not faction or faction == "none" then
    return
  end

  local smartCollection = {}

  for i = 1, #sim_tables.active_levels do
    local lvl = sim_tables.active_levels[i]
    local smarts = sim_levels.level_information[lvl].smarts

    for i = 1, #smarts do
      smartCollection[#smartCollection + 1] = smarts[i]
    end
  end

  return get_nearest_base(smart, faction, smartCollection)
end
function get_nearest_base_on_same_level(smart, faction)
  if not IsSmart(smart) then
    return
  end
  if not faction or faction == "none" then
    return
  end

  local level = game_graph():vertex(smart.m_game_vertex_id):level_id()
  local currentLevelSmarts = sim_levels.level_information[level].smarts
  local smartCollection = {}

  for i = 1, #currentLevelSmarts do
    smartCollection[#smartCollection + 1] = currentLevelSmarts[i]
  end

  return get_nearest_base(smart, faction, smartCollection)
end

function isBase(smart)
  if not IsSmart(smart) then
    utils.debug_stack("ERROR in sim_smart.isBase function, got not a smart object: %s (type: %s)", smart, type(smart))
    return false
  end

  return smart.props and type(smart.props.base) == "number" and smart.props.base > 0
end
function isCamp(smart)
  if not IsSmart(smart) then
    utils.debug_stack("ERROR in sim_smart.isCamp function, got not a smart object: %s (type: %s)", smart, type(smart))
    return false
  end

  return smart.props and type(smart.props.camp) == "number" and smart.props.camp > 0
end
function isPoint(smart)
  if not IsSmart(smart) then
    utils.debug_stack("ERROR in sim_smart.isPoint function, got not a smart object: %s (type: %s)", smart, type(smart))
    return false
  end

  return smart.props and type(smart.props.point) == "number" and smart.props.point > 0
end
function isTerritory(smart)
  if not IsSmart(smart) then
    utils.debug_stack(
      "ERROR in sim_smart.isTerritory function, got not a smart object: %s (type: %s)",
      smart,
      type(smart)
    )
    return false
  end

  return smart.props and type(smart.props.territory) == "number" and smart.props.territory > 0
end
function isResource(smart)
  if not IsSmart(smart) then
    utils.debug_stack(
      "ERROR in sim_smart.isResource function, got not a smart object: %s (type: %s)",
      smart,
      type(smart)
    )
    return false
  end

  return smart.props and type(smart.props.resource) == "number" and smart.props.resource > 0
end
function isLair(smart)
  if not IsSmart(smart) then
    utils.debug_stack("ERROR in sim_smart.isLair function, got not a smart object: %s (type: %s)", smart, type(smart))
    return false
  end

  return smart.props and type(smart.props.lair) == "number" and smart.props.lair > 0
end

function priorityUp(smartId)
  if not prioritySmartsTable[smartId] then
    prioritySmartsTable[smartId] = 0
  end

  prioritySmartsTable[smartId] = prioritySmartsTable[smartId] + 1
end
function priorityDown(smartId)
  if not prioritySmartsTable[smartId] then
    prioritySmartsTable[smartId] = 0
    return
  end

  local priorities = axr_main.config:r_value("mm_options", "enable_priorities", 1, false)

  if not priorities then
    prioritySmartsTable[smartId] = prioritySmartsTable[smartId] - 1
  end
end
function priorityReset(smartId)
  prioritySmartsTable[smartId] = 0
end
function priorityResetAll()
  prioritySmartsTable = {}
end
function hasAnyPriority()
  for smartId, priority in pairs(prioritySmartsTable) do
    if priority > 0 then
      return true
    end
  end

  return false
end
function popMaxPriority()
  local max = 0
  local id = nil

  for smartId, priority in pairs(prioritySmartsTable) do
    if max < priority then
      max = priority
      id = smartId
    end
  end

  if id == nil then
    return nil
  end

  priorityDown(id)

  return id
end

local function npc_on_net_spawn(serverObj, clientObj)
  if not serverObj then
    return
  end
  if not traderOnSmartTable[serverObj:id()] then
    return
  end

  local st = db.storage[serverObj:id()]
  local loaded = false
  local tbl = traderOnSmartTable[serverObj:id()]

  serverObj:inactualize_patrol_path()

  local ltx_name = strformat("scripts\\%s", tbl.logic)
  local ltx = ini_file(ltx_name)
  if not (ltx) then
    assert("ERROR: do not have access to scripts\\beh_hunter.ltx! Make sure you installed properly!")
    return
  end

  xr_logic.configure_schemes(
    serverObj,
    ltx,
    ltx_name,
    modules.stype_stalker,
    loaded and st.loaded_section_logic or "logic",
    ""
  )

  local section =
    loaded and st.loaded_active_section or xr_logic.determine_section_to_activate(serverObj, ltx, "logic", db.actor)
  xr_logic.activate_by_section(serverObj, ltx, section, "", loaded)
end
local function npc_on_death_callback(npc, who)
  local id = npc:id()

  if not traderOnSmartTable[id] or not traderOnSmartTable[id].smartId then
    return
  end

  local smart = alife_object(traderOnSmartTable[id].smartId)

  local tbl = uniqueSmarts[smart:name()]

  if tbl and tbl[6] then
    tbl[6] = nil
    uniqueSmarts[smart:name()] = tbl

    traderOnSmartTable[id] = nil
  end
end
local function squad_on_switched_to_online(squad)
  if not squad:name():match("_sim_squad_trader") then
    return
  end

  for k in squad:squad_members() do
    local npc = db.storage[k.id] and db.storage[k.id].object
    if traderOnSmartTable[k.id] and npc then
      npc_on_net_spawn(npc)
    end
  end
end
local function squad_on_remove(squad)
  if not IsSquad(squad) then
    return
  end

  if already_captured_smarts[squad.current_target_id] then
    local smart = squad.current_target_id and alife_object(squad.current_target_id)

    if IsSmart(smart) then
      utils.news(gs("st_sim_smart_attention"), gs("st_sim_smart_squad_die"), gs(smart:name()))
    end
    already_captured_smarts[squad.current_target_id] = nil
  end
end

local function actor_on_first_update()
  local pda_smart_icons_size = axr_main.config:r_value("mm_options", "pda_smart_icons_size", 2, 24)

  sim_smart.pda_smart_icons_size_old = pda_smart_icons_size
end

local function save_state(m_data)
  if m_data.traderOnSmartTable == nil then
    m_data.already_captured_smarts = {}
    m_data.prioritySmartsTable = {}
    m_data.traderOnSmartTable = {}
    m_data.spawned_leaders_squads = {}
  end

  m_data.already_captured_smarts = already_captured_smarts
  m_data.traderOnSmartTable = traderOnSmartTable
  m_data.prioritySmartsTable = prioritySmartsTable
  m_data.uniqueSmarts = uniqueSmarts
  m_data.spawned_leaders_squads = spawned_leaders_squads
  m_data.hunt_by_actor_time = hunt_by_actor_time
  m_data.hunt_by_actor_infinity = hunt_by_actor_infinity
end
local function load_state(m_data)
  already_captured_smarts = m_data.already_captured_smarts ~= nil and m_data.already_captured_smarts or {}
  traderOnSmartTable = m_data.traderOnSmartTable ~= nil and m_data.traderOnSmartTable or {}
  prioritySmartsTable = m_data.prioritySmartsTable ~= nil and m_data.prioritySmartsTable or {}
  uniqueSmarts = m_data.uniqueSmarts ~= nil and m_data.uniqueSmarts or uniqueSmarts
  spawned_leaders_squads = m_data.spawned_leaders_squads ~= nil and m_data.spawned_leaders_squads or {}
  hunt_by_actor_time = m_data.hunt_by_actor_time ~= nil and m_data.hunt_by_actor_time or {}
  hunt_by_actor_infinity = m_data.hunt_by_actor_infinity ~= nil and m_data.hunt_by_actor_infinity or {}

  m_data.traderOnSmartTable = nil
  m_data.prioritySmartsTable = nil
  m_data.uniqueSmarts = nil
  m_data.spawned_leaders_squads = nil
end

function InitTables()
  for _, faction in pairs(sim_tables.factions) do
    hunt_by_actor_time[faction] = nil
    hunt_by_actor_infinity[faction] = false
  end
end

function on_game_start()
  RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
  RegisterScriptCallback("npc_on_net_spawn", npc_on_net_spawn)
  RegisterScriptCallback("npc_on_death_callback", npc_on_death_callback)
  RegisterScriptCallback("squad_on_switched_to_online", squad_on_switched_to_online)
  RegisterScriptCallback("squad_on_remove", squad_on_remove)
  RegisterScriptCallback("save_state", save_state)
  RegisterScriptCallback("load_state", load_state)

  InitTables()
end
